Create HEAP and STACK Diagram for the following programs :
----------------------------------------------------------
class Customer
{
	private String name;
	private int id;

	public Customer(String name , int id) 
	{
		super();
		this.name=name;
		this.id=id;
	}

	public void setId(int id)   //setter
	{
		this.id=id;
	}

	public int getId() //getter
	{
		return this.id;
	}
}

public class CustomerDemo
{
	public static void main(String[] args) 
	{
		int val = 100;

		Customer c = new Customer("Ravi",2);

                m1(c);   
		
		//GC [Write Here How many objects are eligible for GC]

		System.out.println(c.getId());
	}

	public static void m1(Customer cust) 
	{
		cust.setId(5);

	    cust = new Customer("Rahul",7);

		cust.setId(9);
		System.out.println(cust.getId());
	}
}  
==========================================================================================
Step 1: main() starts

Stack:

main()
  val = 100


Heap:

Nothing yet.

Step 2: Customer c = new Customer("Ravi", 2);

Heap:

Object	Fields
Customer#1	name = "Ravi", id = 2

Stack:

main()
  val = 100
  c → Customer#1

Step 3: Call m1(c)

A new stack frame is created for m1().

Stack:

main()
  val = 100
  c → Customer#1
m1()
  cust → Customer#1  // passed by reference

Step 4: Inside m1

cust.setId(5);
→ modifies the same object Customer#1.

Customer#1 now has:

name = "Ravi"
id = 5


cust = new Customer("Rahul",7);
→ creates a new Customer object on heap.

Heap now:

Object	Fields
Customer#1	name="Ravi", id=5
Customer#2	name="Rahul", id=7

Now cust points to Customer#2, but main’s variable c still points to Customer#1.

cust.setId(9);
→ modifies Customer#2 to id = 9.

System.out.println(cust.getId());
→ prints 9.

Step 5: m1 ends

Local variable cust (which was pointing to Customer#2) is removed from stack.

Now only main.c → Customer#1 remains.

✅ Customer#2 has no reference → becomes eligible for GC.

Step 6: Back to main()

System.out.println(c.getId()); → prints 5.

🧾 Output:
9
5
==========================================================================================
Stack:
======

main()
  val = 100
  c → Customer#1


Heap:
=====

Customer#1: { name="Ravi", id=5 }
Customer#2: { name="Rahul", id=9 }   ← GC eligible


==========================================================================================
public class Employee
{
	int id = 100;
	
	public static void main(String[] args) 
	{
		int val = 200;

		Employee e1 = new Employee();     

		e1.id = val;

		update(e1);	  
		
		System.out.println(e1.id);

        Employee e2 = new Employee(); 

		e2.id = 900;
        
		switchEmployees(e2,e1); 

		  //GC [How many objects are eligible for GC]

			System.out.println(e1.id);
		    System.out.println(e2.id);
	    } 
		
	 public static void update(Employee e)  
	 {
        e.id = 500;
		e = new Employee();
		e.id = 400;
		System.out.println(e.id);
	 }

	 public static void switchEmployees(Employee e1, Employee e2)
	  {
		 int temp = e1.id; 
		 e1.id = e2.id; 
		 e2 = new Employee();
		 e2.id = temp;
	  }
   }
==================================================================================================
Step 1: main()
val = 200

Step 2: Employee e1 = new Employee();

Heap:

Object	id
Employee#1	100

Then e1.id = val; → id = 200

Employee#1: id = 200

Step 3: update(e1);

Stack:

main()
  val = 200
  e1 → Employee#1
update()
  e → Employee#1


Inside update():

e.id = 500; → changes Employee#1.id = 500

e = new Employee(); → new object created (Employee#2)

e.id = 400; → Employee#2.id = 400

print 400

Then update() ends → local e dies → Employee#2 has no reference → eligible for GC

Back to main(), e1 → Employee#1(id=500)

Step 4: System.out.println(e1.id); → prints 500.
Step 5: Employee e2 = new Employee(); e2.id = 900;

Creates Employee#3 on heap.

Now:

Reference	Object
e1	Employee#1(id=500)
e2	Employee#3(id=900)
Step 6: switchEmployees(e2,e1)

Stack during call:

main()
  e1 → Employee#1
  e2 → Employee#3
switchEmployees()
  e1 → Employee#3
  e2 → Employee#1


Inside switchEmployees():

temp = e1.id; → temp = 900

e1.id = e2.id; → Employee#3.id = 500

e2 = new Employee(); → creates Employee#4

e2.id = temp; → Employee#4.id = 900

Now:

Local e2 points to Employee#4

But main’s e1 and e2 still point to Employee#1 and Employee#3 respectively.

switchEmployees() ends → local e2 gone → Employee#4 becomes GC eligible.

Step 7: Print:
System.out.println(e1.id); → 500
System.out.println(e2.id); → 500


✅ because Employee#1.id = 500, Employee#3.id = 500

🧾 Output:
400
500
500
500
=====================================================================================================

