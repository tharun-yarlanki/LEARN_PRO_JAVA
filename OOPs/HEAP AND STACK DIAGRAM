Create HEAP and STACK Diagram for the following programs :
----------------------------------------------------------
class Customer
{
	private String name;
	private int id;

	public Customer(String name , int id) 
	{
		super();
		this.name=name;
		this.id=id;
	}

	public void setId(int id)   //setter
	{
		this.id=id;
	}

	public int getId() //getter
	{
		return this.id;
	}
}

public class CustomerDemo
{
	public static void main(String[] args) 
	{
		int val = 100;

		Customer c = new Customer("Ravi",2);

                m1(c);   
		
		//GC [Write Here How many objects are eligible for GC]

		System.out.println(c.getId());
	}

	public static void m1(Customer cust) 
	{
		cust.setId(5);

	    cust = new Customer("Rahul",7);

		cust.setId(9);
		System.out.println(cust.getId());
	}
}  
==========================================================================================
Step 1: main() starts

Stack:

main()
  val = 100


Heap:

Nothing yet.

Step 2: Customer c = new Customer("Ravi", 2);

Heap:

Object	Fields
Customer#1	name = "Ravi", id = 2

Stack:

main()
  val = 100
  c â†’ Customer#1

Step 3: Call m1(c)

A new stack frame is created for m1().

Stack:

main()
  val = 100
  c â†’ Customer#1
m1()
  cust â†’ Customer#1  // passed by reference

Step 4: Inside m1

cust.setId(5);
â†’ modifies the same object Customer#1.

Customer#1 now has:

name = "Ravi"
id = 5


cust = new Customer("Rahul",7);
â†’ creates a new Customer object on heap.

Heap now:

Object	Fields
Customer#1	name="Ravi", id=5
Customer#2	name="Rahul", id=7

Now cust points to Customer#2, but mainâ€™s variable c still points to Customer#1.

cust.setId(9);
â†’ modifies Customer#2 to id = 9.

System.out.println(cust.getId());
â†’ prints 9.

Step 5: m1 ends

Local variable cust (which was pointing to Customer#2) is removed from stack.

Now only main.c â†’ Customer#1 remains.

âœ… Customer#2 has no reference â†’ becomes eligible for GC.

Step 6: Back to main()

System.out.println(c.getId()); â†’ prints 5.

ğŸ§¾ Output:
9
5
==========================================================================================
Stack:
======

main()
  val = 100
  c â†’ Customer#1


Heap:
=====

Customer#1: { name="Ravi", id=5 }
Customer#2: { name="Rahul", id=9 }   â† GC eligible


==========================================================================================
public class Employee
{
	int id = 100;
	
	public static void main(String[] args) 
	{
		int val = 200;

		Employee e1 = new Employee();     

		e1.id = val;

		update(e1);	  
		
		System.out.println(e1.id);

        Employee e2 = new Employee(); 

		e2.id = 900;
        
		switchEmployees(e2,e1); 

		  //GC [How many objects are eligible for GC]

			System.out.println(e1.id);
		    System.out.println(e2.id);
	    } 
		
	 public static void update(Employee e)  
	 {
        e.id = 500;
		e = new Employee();
		e.id = 400;
		System.out.println(e.id);
	 }

	 public static void switchEmployees(Employee e1, Employee e2)
	  {
		 int temp = e1.id; 
		 e1.id = e2.id; 
		 e2 = new Employee();
		 e2.id = temp;
	  }
   }
==================================================================================================
Step 1: main()
val = 200

Step 2: Employee e1 = new Employee();

Heap:

Object	id
Employee#1	100

Then e1.id = val; â†’ id = 200

Employee#1: id = 200

Step 3: update(e1);

Stack:

main()
  val = 200
  e1 â†’ Employee#1
update()
  e â†’ Employee#1


Inside update():

e.id = 500; â†’ changes Employee#1.id = 500

e = new Employee(); â†’ new object created (Employee#2)

e.id = 400; â†’ Employee#2.id = 400

print 400

Then update() ends â†’ local e dies â†’ Employee#2 has no reference â†’ eligible for GC

Back to main(), e1 â†’ Employee#1(id=500)

Step 4: System.out.println(e1.id); â†’ prints 500.
Step 5: Employee e2 = new Employee(); e2.id = 900;

Creates Employee#3 on heap.

Now:

Reference	Object
e1	Employee#1(id=500)
e2	Employee#3(id=900)
Step 6: switchEmployees(e2,e1)

Stack during call:

main()
  e1 â†’ Employee#1
  e2 â†’ Employee#3
switchEmployees()
  e1 â†’ Employee#3
  e2 â†’ Employee#1


Inside switchEmployees():

temp = e1.id; â†’ temp = 900

e1.id = e2.id; â†’ Employee#3.id = 500

e2 = new Employee(); â†’ creates Employee#4

e2.id = temp; â†’ Employee#4.id = 900

Now:

Local e2 points to Employee#4

But mainâ€™s e1 and e2 still point to Employee#1 and Employee#3 respectively.

switchEmployees() ends â†’ local e2 gone â†’ Employee#4 becomes GC eligible.

Step 7: Print:
System.out.println(e1.id); â†’ 500
System.out.println(e2.id); â†’ 500


âœ… because Employee#1.id = 500, Employee#3.id = 500

ğŸ§¾ Output:
400
500
500
500
=====================================================================================================

